import { useState, useEffect, useCallback } from 'react';
import { DndProvider } from 'react-dnd';
import { HTML5Backend } from 'react-dnd-html5-backend';
import { EncodingTypesList, OperationType } from '@/app/components/decoder/EncodingTypesList';
import { EncodingChain, EncodingOperation } from '@/app/components/decoder/EncodingChain';
import { OperationArea } from '@/app/components/decoder/OperationArea';
import { runPipeline, getSBoxNames, convertFormat } from '@/app/api';

export function DecoderPage() {
  const [chain, setChain] = useState<EncodingOperation[]>([]);
  const [input, setInput] = useState('');
  const [output, setOutput] = useState('');
  const [inputFormat, setInputFormat] = useState('UTF-8');
  const [outputFormat, setOutputFormat] = useState('UTF-8');
  const [sboxNames, setSboxNames] = useState<string[]>(['Standard AES', 'Standard SM4']);
  const [isProcessing, setIsProcessing] = useState(false);
  const [error, setError] = useState<string | null>(null);

  // Load S-Box names on mount
  useEffect(() => {
    const loadSboxNames = async () => {
      try {
        const names = await getSBoxNames();
        setSboxNames(names);
      } catch (e) {
        console.error('Failed to load S-Box names:', e);
      }
    };
    loadSboxNames();
  }, []);

  const addToChain = (type: OperationType, defaultParams?: Record<string, any>) => {
    const newOp: EncodingOperation = {
      id: `${type}-${Date.now()}-${Math.random().toString(36).slice(2, 9)}`,
      type,
      params: defaultParams ? { ...defaultParams } : {},
      enabled: true,
    };
    setChain([...chain, newOp]);
  };

  const removeFromChain = (id: string) => {
    setChain(chain.filter(op => op.id !== id));
  };

  const updateParams = (id: string, params: Record<string, any>) => {
    setChain(chain.map(op => op.id === id ? { ...op, params } : op));
  };

  const toggleOperation = (id: string) => {
    setChain(chain.map(op => op.id === id ? { ...op, enabled: !op.enabled } : op));
  };

  const moveOperation = (dragIndex: number, hoverIndex: number) => {
    const newChain = [...chain];
    const [removed] = newChain.splice(dragIndex, 1);
    newChain.splice(hoverIndex, 0, removed);
    setChain(newChain);
  };

  const executeRecipe = useCallback(async () => {
    if (chain.length === 0) {
      setError('请先添加操作到编码链');
      return;
    }

    setIsProcessing(true);
    setError(null);

    try {
      let currentInput = input;
      let skipConversion = false;

      // Smart Input Handling: for crypto ops with HEX input, pass data_type directly
      const activeRecipe = chain.filter(op => op.enabled);
      if (activeRecipe.length > 0 && inputFormat === 'HEX') {
        const firstOpId = activeRecipe[0].type;
        const cryptoOps = ['aes_encrypt', 'aes_decrypt', 'sm4_encrypt', 'sm4_decrypt',
          'des_encrypt', 'des_decrypt', 'triple_des_encrypt', 'triple_des_decrypt',
          'rc4_encrypt', 'rc4_decrypt'];
        if (cryptoOps.includes(firstOpId)) {
          skipConversion = true;
        }
      }

      // Convert input format if needed
      if (!skipConversion && inputFormat !== 'UTF-8') {
        currentInput = await convertFormat(currentInput, inputFormat, 'UTF-8');
      }

      // Build operations array
      const operations = activeRecipe.map((op, index) => {
        const params = { ...op.params };
        // Inject data_type for first op if using Hex mode with crypto
        if (index === 0 && skipConversion && inputFormat === 'HEX') {
          params.data_type = 'hex';
        }
        return { name: op.type, params };
      });

      // Run pipeline
      let result = await runPipeline(currentInput, operations);

      // Convert output format if needed
      if (outputFormat !== 'UTF-8') {
        result = await convertFormat(result, 'UTF-8', outputFormat);
      }

      setOutput(result);
    } catch (e: any) {
      console.error('Execute Recipe Error:', e);
      setOutput(`[错误] ${e.message}`);
      setError(e.message);
    } finally {
      setIsProcessing(false);
    }
  }, [chain, input, inputFormat, outputFormat]);

  return (
    <DndProvider backend={HTML5Backend}>
      <div className="h-full flex flex-col p-6 gap-4">
        {/* Header */}
        <div className="flex-shrink-0 flex items-center justify-between">
          <div className="inline-flex items-center gap-3 px-5 py-2.5 bg-gradient-to-r from-pink-500/10 via-rose-500/10 to-pink-500/10 rounded-full border border-pink-200/50 backdrop-blur-sm">
            <div className="w-2 h-2 rounded-full bg-pink-500 animate-pulse"></div>
            <h1 className="text-2xl text-transparent bg-clip-text bg-gradient-to-r from-pink-600 to-rose-600 font-semibold">解码器</h1>
          </div>
          {error && (
            <div className="text-sm text-red-500 bg-red-50 px-4 py-2 rounded-lg">
              {error}
            </div>
          )}
        </div>

        {/* Main Layout */}
        <div className="flex-1 flex gap-4 min-h-0">
          {/* Left: Encoding Types */}
          <div className="w-56 flex-shrink-0">
            <EncodingTypesList onAddToChain={addToChain} />
          </div>

          {/* Middle: Encoding Chain */}
          <div className="w-72 flex-shrink-0">
            <EncodingChain
              chain={chain}
              onRemove={removeFromChain}
              onUpdateParams={updateParams}
              onMove={moveOperation}
              onToggle={toggleOperation}
              sboxNames={sboxNames}
            />
          </div>

          {/* Right: Operation Area */}
          <div className="flex-1 min-w-0">
            <OperationArea
              input={input}
              output={output}
              inputFormat={inputFormat}
              outputFormat={outputFormat}
              isProcessing={isProcessing}
              onInputChange={setInput}
              onInputFormatChange={setInputFormat}
              onOutputFormatChange={setOutputFormat}
              onExecute={executeRecipe}
            />
          </div>
        </div>
      </div>
    </DndProvider>
  );
}
