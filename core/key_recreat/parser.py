
import ast
import json
from typing import List, Dict, Any, Optional, Tuple

def parse_code_to_blocks(code: str, blocks_def: Dict[str, Any]) -> List[Dict[str, Any]]:
    """
    Parse Python code and attempt to reconstruct block chain.
    Uses a cursor-based approach to consume multiple statements for complex blocks.
    """
    try:
        tree = ast.parse(code)
    except Exception as e:
        return [{"block_id": "raw_code", "params": {"code": f"# Parse Error: {e}"}}]

    chain = []
    body = tree.body
    
    # Unwrap top-level function if exists (ignoring imports)
    meaningful_nodes = [
        node for node in body 
        if not isinstance(node, (ast.Import, ast.ImportFrom, ast.Pass))
    ]
    
    if len(meaningful_nodes) == 1 and isinstance(meaningful_nodes[0], ast.FunctionDef):
        body = meaningful_nodes[0].body
    
    i = 0
    while i < len(body):
        # Try to match starting from current index
        blocks, nodes_consumed = match_sequence(body, i, blocks_def)
        
        if blocks:
            chain.extend(blocks)
            i += nodes_consumed
        
        elif isinstance(body[i], (ast.Import, ast.ImportFrom)):
            # Ignore imports, they are regenerated by blocks
            i += 1
            
        elif isinstance(body[i], ast.Pass):
             # Ignore pass
             i += 1
             
        else:
            # Unrecognized -> Raw Code
            # Try to group consecutive unrecognized lines?
            # For now, just one line at a time
            node = body[i]
            try:
                raw_code = ast.unparse(node)
                # Filter out implicit 'pass' if we have empty bodies (not likely here as we check node types)
                chain.append({
                    "id": f"raw_{id(node)}",
                    "block_id": "raw_code",
                    "params": {"code": raw_code}
                })
            except:
                pass
            i += 1
            
    return chain

def match_sequence(statements: List[ast.AST], start_index: int, blocks_def: Dict[str, Any]) -> Tuple[List[Dict[str, Any]], int]:
    """
    Try to match one or more statements to a block (or sequence of blocks).
    Returns (List[BlockInstance], consumed_count).
    """
    if start_index >= len(statements):
        return [], 0

    node = statements[start_index]
    
    def create_block(block_id: str, params: Dict[str, Any], meta_id: str = None) -> Dict[str, Any]:
        return {
            "id": meta_id or f"gen_{block_id}_{id(node)}_{id(params)}",
            "block_id": block_id,
            "params": params
        }

    # helper for checking Call args
    def get_arg_value(call_node, index=0):
        if index < len(call_node.args):
            arg = call_node.args[index]
            if isinstance(arg, ast.Constant):
                return arg.value
            # Handle variable or simple binary op
            try:
                return ast.unparse(arg)
            except:
                return None
        return None
        
    def get_node_value(n):
        if isinstance(n, ast.Constant): return n.value
        try: return ast.unparse(n)
        except: return None

    # --- Malware / PRNG Blocks ---
    
    # Pattern: prng_cryptgenrandom -> data = os.urandom(length)
    if isinstance(node, ast.Assign):
        if is_call_to(node.value, 'os', 'urandom'):
            # Check target name
            target = get_assignment_target(node)
            length = get_arg_value(node.value)
            
            if target == 'key':
                # Heuristic for crypto_genkey_aes: bits // 8
                arg = node.value.args[0]
                bits = 256
                if isinstance(arg, ast.BinOp) and isinstance(arg.op, ast.FloorDiv) and isinstance(arg.right, ast.Constant) and arg.right.value == 8:
                    if isinstance(arg.left, ast.Constant): bits = arg.left.value
                elif isinstance(length, int): bits = length * 8
                
                return [create_block("crypto_genkey_aes", {"bits": bits}, f"genkey_{id(node)}")], 1

            return [create_block("prng_cryptgenrandom", {"length": length if isinstance(length, int) else 32}, f"prng_{id(node)}")], 1

    # Pattern: prng_weak_srand -> random.seed(...); data = random.randbytes(...)
    if start_index + 1 < len(statements):
        node2 = statements[start_index + 1]
        is_seed = False
        if isinstance(node, ast.Expr) and is_call_to(node.value, 'random', 'seed'):
            is_seed = True
        
        if is_seed and isinstance(node2, ast.Assign) and is_call_to(node2.value, 'random', 'randbytes'):
            length = get_arg_value(node2.value)
            return [create_block("prng_weak_srand", {"length": length if isinstance(length, int) else 32}, f"weak_prng_{id(node)}")], 2
            
    # Pattern: dynamic_load_api -> print( ... )
    if isinstance(node, ast.Expr) and isinstance(node.value, ast.Call) and isinstance(node.value.func, ast.Name) and node.value.func.id == 'print':
        pass 

    # --- Hashing ---
    # data = hashlib.md5(data).digest()
    if isinstance(node, ast.Assign) and isinstance(node.value, ast.Call):
        if isinstance(node.value.func, ast.Attribute) and node.value.func.attr == 'digest':
            inner = node.value.func.value
            if is_call_to(inner, 'hashlib', 'md5'):
                 return [create_block("hash_md5", {}, f"md5_{id(node)}")], 1
            if is_call_to(inner, 'hashlib', 'sha256'):
                 return [create_block("hash_sha256", {}, f"sha256_{id(node)}")], 1
                 
    # --- Input Blocks & Data Flow ---
    if isinstance(node, ast.Assign):
        target = get_assignment_target(node)
        val = node.value
        blocks = []
        
        # data = bytes.fromhex('...')  (Support formhex typo)
        if is_call_to(val, 'bytes', 'fromhex') or is_call_to(val, 'bytes', 'formhex'):
            hex_str = get_arg_value(val)
            # Check if arg is variable
            arg0 = val.args[0] if val.args else None
            if isinstance(arg0, ast.Name):
                 # Variable -> hex_decode
                 # Implicit flow wrapping
                 if arg0.id != 'data':
                     blocks.append(create_block("load_var", {"var_name": arg0.id}))
                 blocks.append(create_block("hex_decode", {}, f"hex_dec_{id(node)}"))
                 if target and target != 'data':
                      blocks.append(create_block("assign_var", {"var_name": target}))
                 return blocks, 1
            
            # If literal, input_hex
            return [create_block("input_hex", {"hex_string": hex_str or ""}, f"hex_{id(node)}")], 1

        # data = '...'.encode(...) 
        if isinstance(val, ast.Call) and isinstance(val.func, ast.Attribute) and val.func.attr == 'encode':
             if isinstance(val.func.value, ast.Constant) and isinstance(val.func.value.value, str):
                 return [create_block("input_string", {"text": val.func.value.value}, f"str_{id(node)}")], 1
        
        # data = 123
        if isinstance(val, ast.Constant) and isinstance(val.value, int):
             return [create_block("input_int", {"value": val.value}, f"int_{id(node)}")], 1

        # data = bytes([...])
        if isinstance(val, ast.Call) and isinstance(val.func, ast.Name) and val.func.id == 'bytes':
             if val.args and isinstance(val.args[0], ast.List):
                 try:
                     content = ast.unparse(val.args[0])[1:-1]
                     return [create_block("input_bytes", {"bytes_list": content}, f"bytes_{id(node)}")], 1
                 except: pass

        # --- CTypes / Libc / Struct (Advanced) ---
        
        # libc = ctypes.CDLL("...")
        if is_call_to(val, 'ctypes', 'CDLL'):
             arg = get_arg_value(val)
             return [create_block("ctypes_load_library", 
                {"lib_name": arg or "libc.so.6", "var_name": target or "libc"}, f"cdll_{id(node)}")], 1

        # data = libc.rand()
        if isinstance(val, ast.Call) and isinstance(val.func, ast.Attribute) and val.func.attr == 'rand':
             lib_var = ast.unparse(val.func.value)
             blocks.append(create_block("libc_rand", {"lib_var": lib_var}, f"rand_{id(node)}"))
             if target and target != 'data':
                 blocks.append(create_block("assign_var", {"var_name": target}))
             return blocks, 1

        # data = int.from_bytes(arg, ...) (Support form_bytes typo)
        if is_call_to(val, 'int', 'from_bytes') or is_call_to(val, 'int', 'form_bytes'):
             byteorder = 'big'
             for kw in val.keywords:
                 if kw.arg == 'byteorder' and isinstance(kw.value, ast.Constant):
                     byteorder = kw.value.value
             
             src_arg = get_node_value(val.args[0]) if val.args else None
             if src_arg and src_arg != 'data':
                 blocks.append(create_block("load_var", {"var_name": src_arg}))
             
             blocks.append(create_block("int_from_bytes", {"byteorder": byteorder}, f"int_bytes_{id(node)}"))
             
             if target and target != 'data':
                 blocks.append(create_block("assign_var", {"var_name": target}))
             return blocks, 1

        # struct.pack(fmt, val)
        if is_call_to(val, 'struct', 'pack'):
             fmt = get_arg_value(val, 0)
             
             # Arg 1 processing
             if len(val.args) > 1:
                 arg1 = val.args[1]
                 # Unpack BinOp (e.g. x & 0xFF)
                 if isinstance(arg1, ast.BinOp) and isinstance(arg1.op, ast.BitAnd):
                     left_val = get_node_value(arg1.left)
                     if left_val and left_val != 'data':
                         blocks.append(create_block("load_var", {"var_name": left_val}))
                     
                     mask = "FFFFFFFF"
                     if isinstance(arg1.right, ast.Constant):
                         mask = f"{arg1.right.value:X}"
                     blocks.append(create_block("int_and", {"mask": mask}))
                 else:
                     # Standard var
                     v = get_node_value(arg1)
                     if v and v != 'data':
                         blocks.append(create_block("load_var", {"var_name": v}))
             
             blocks.append(create_block("struct_pack", {"fmt": fmt or "<I"}, f"pack_{id(node)}"))
             
             if target and target != 'data':
                 blocks.append(create_block("assign_var", {"var_name": target}))
             return blocks, 1

        # int_and: x & 0xFF (simple assign)
        if isinstance(val, ast.BinOp) and isinstance(val.op, ast.BitAnd):
             # Assume wrapping needed if target != data or left != data
             left_val = get_node_value(val.left)
             if left_val and left_val != 'data':
                 blocks.append(create_block("load_var", {"var_name": left_val}))
             
             mask = "FF"
             if isinstance(val.right, ast.Constant): mask = f"{val.right.value:X}"
             blocks.append(create_block("int_and", {"mask": mask}, f"and_{id(node)}"))
             
             if target and target != 'data':
                 blocks.append(create_block("assign_var", {"var_name": target}))
             return blocks, 1


    # libc.srand(seed)  (Expr)
    if isinstance(node, ast.Expr) and isinstance(node.value, ast.Call):
         func = node.value.func
         if isinstance(func, ast.Attribute) and func.attr == 'srand':
             lib_var = ast.unparse(func.value)
             seed_arg = get_arg_value(node.value) 
             # Check if seed_arg is variable? 
             # Parser get_arg_value returns unparsed if not Constant.
             # libc_srand block expecting 'seed' param (var name or data).
             # Default param "start" (from code blocks.py? No, 'seed': seed_arg or 'data').
             # The block code is `libc.srand({seed})`.
             # So passing variable name works fine.
             return [create_block("libc_srand", {"lib_var": lib_var, "seed": seed_arg or "data"}, f"srand_{id(node)}")], 1

    # buffer += data (AugAssign)
    if isinstance(node, ast.AugAssign) and isinstance(node.op, ast.Add):
         target = ast.unparse(node.target)
         return [create_block("buffer_append", {"target": target}, f"append_{id(node)}")], 1
    
    # buffer = b""
    if isinstance(node, ast.Assign) and isinstance(node.value, ast.Constant) and node.value.value == b"":
         target = get_assignment_target(node)
         return [create_block("buffer_init", {"var_name": target}, f"buf_init_{id(node)}")], 1

    # --- Transforms (XOR) ---
    if isinstance(node, ast.Assign) and isinstance(node.value, ast.Call) and isinstance(node.value.func, ast.Name) and node.value.func.id == 'bytes':
        if node.value.args and isinstance(node.value.args[0], ast.GeneratorExp):
            elt = node.value.args[0].elt
            if isinstance(elt, ast.BinOp) and isinstance(elt.op, ast.BitXor):
                # Try to find constant
                others = []
                if isinstance(elt.right, ast.Constant): others.append(elt.right.value)
                if isinstance(elt.left, ast.Constant): others.append(elt.left.value)
                if others:
                     hex_val = f"{others[0]:02X}"
                     return [create_block("xor_const", {"key": hex_val}, f"xor_{id(node)}")], 1

    # --- Loops ---
    if isinstance(node, ast.For):
        if is_call_to(node.iter, None, 'range'):
             arg = get_arg_value(node.iter)
             children = []
             j = 0
             while j < len(node.body):
                 child_blocks, consumed = match_sequence(node.body, j, blocks_def)
                 if child_blocks:
                     children.extend(child_blocks)
                     j += consumed
                 else:
                     try:
                         raw = ast.unparse(node.body[j])
                         children.append(create_block("raw_code", {"code": raw}, f"raw_{j}"))
                     except: pass
                     j += 1
                     
             return [create_block("for_range", {"count": arg if isinstance(arg, int) else 16}, f"loop_{id(node)}") | {"children": children}], 1
    
    # --- Generic Custom Block Matching ---
    for b_id, b_def in blocks_def.items():
        cat = b_def.get('category')
        if cat in ('custom', 'function', 'transform') or b_def.get('is_custom'):
            # Basic optimization: check if first word of code matches node type?
            # Skip heavy parsing if possible.
            # But simpler to just try match.
            res = match_template(statements[start_index:], b_def)
            if res:
                params, consumed = res
                return [create_block(b_id, params, f"custom_{id(node)}_{b_id}")], consumed

    # --- Returns ---
    # Handled by generic custom matcher above


    return [], 0

def match_template(target_nodes: List[ast.AST], block_def: Dict[str, Any]) -> Optional[Tuple[Dict[str, Any], int]]:
    """
    Matches target AST nodes against a block's code template.
    Returns (extracted_params, consumed_node_count) or None.
    """
    code_template = block_def.get('code', '')
    params_def = block_def.get('params', [])
    
    # 1. Prepare Template w/ Placeholders
    # We replace {param} with _VAR_param
    mapping = {p['name']: f"_VAR_{p['name']}" for p in params_def}
    
    try:
        # Use simple string replace for robustness if format fails? 
        # But format is best for {param}.
        # We assume user uses {param} syntax.
        # If code has { or } literals (e.g. dict), this crashes.
        # Fallback: simple replace?
        formatted_code = code_template
        for k, v in mapping.items():
            formatted_code = formatted_code.replace(f"{{{k}}}", v)
            
        # 2. Parse Template
        template_ast = ast.parse(formatted_code)
        template_body = template_ast.body
        
        # Filter imports/pass from template body? 
        # Usually custom block has specific logic.
        template_nodes = [n for n in template_body if not isinstance(n, (ast.Import, ast.ImportFrom, ast.Pass))]
        
        if not template_nodes:
            return None # Empty block?
            
        if len(target_nodes) < len(template_nodes):
            return None
            
        # 3. Compare Nodes
        extracted_params = {}
        for i, t_node in enumerate(template_nodes):
            if not ast_match(t_node, target_nodes[i], extracted_params):
                return None
                
        # 4. Success
        # Clean up params (stripping quotes etc if needed? ast.unparse handles it)
        return extracted_params, len(template_nodes)
        
    except Exception as e:
        # print(f"Template match error for {block_def.get('name')}: {e}")
        return None

def ast_match(template: Any, target: Any, params: Dict[str, Any]) -> bool:
    """Recursively compare AST nodes and extract params."""
    if template is None and target is None: return True
    if template is None or target is None: return False
    
    # If template is the placeholder variable
    if isinstance(template, ast.Name) and template.id.startswith("_VAR_"):
        param_name = template.id[5:] # remove _VAR_
        
        # Extract value from target
        try:
            val = ast.unparse(target)
            # Try to convert to int/float if feasible?
            # But params are usually string unless specified.
            # Block params are typed.
            # Convert based on block def?
            # For now, store raw unparsed string.
            # If target is Constant string, unparse adds quotes.
            if isinstance(target, ast.Constant):
                # We want the raw value for the param form?
                # If param type is 'text', we want 'hello', not '"hello"'.
                val = target.value
                
            params[param_name] = val
            return True
        except:
            return False

    if type(template) != type(target):
        return False
        
    # Compare fields
    for field in template._fields:
        val1 = getattr(template, field, None)
        val2 = getattr(target, field, None)
        
        if isinstance(val1, list):
            if not isinstance(val2, list) or len(val1) != len(val2):
                return False
            for i in range(len(val1)):
                if not ast_match(val1[i], val2[i], params):
                    return False
        elif isinstance(val1, ast.AST):
            if not ast_match(val1, val2, params):
                return False
        else:
            # Primitive checking
            # Ignore context/cols
            if field in ('lineno', 'col_offset', 'end_lineno', 'end_col_offset', 'ctx'):
                continue
            if val1 != val2:
                return False
                
    return True

def get_assignment_target(node: ast.Assign) -> str:
    if len(node.targets) == 1 and isinstance(node.targets[0], ast.Name):
        return node.targets[0].id
    return ""

def is_call_to(node: ast.AST, module: Optional[str], func_name: str) -> bool:
    """Checks if node is a call to [module.]func_name"""
    if not isinstance(node, ast.Call):
        return False
    
    func = node.func
    if module:
        # module.func
        return (isinstance(func, ast.Attribute) and 
                isinstance(func.value, ast.Name) and 
                func.value.id == module and 
                func.attr == func_name)
    else:
        # func
        return isinstance(func, ast.Name) and func.id == func_name

